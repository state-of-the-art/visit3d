import{BackSide as a,Color as b,ShaderMaterial as c,UniformsLib as d,UniformsUtils as e}from"three";class OutlineEffect{constructor(g,f={}){this.enabled=!0;let h=void 0!==f.defaultThickness?f.defaultThickness:.003,i=new b().fromArray(void 0!==f.defaultColor?f.defaultColor:[0,0,0]),j=void 0!==f.defaultAlpha?f.defaultAlpha:1,k=void 0!==f.defaultKeepAlive&&f.defaultKeepAlive,l={},m={},n={},o={outlineThickness:{value:h},outlineColor:{value:i},outlineAlpha:{value:j}};function p(){return new c({type:"OutlineEffect",uniforms:e.merge([d.fog,d.displacementmap,o]),vertexShader:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nuniform float outlineThickness;\nvec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {\n float thickness = outlineThickness;\n const float ratio = 1.0;\n  vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );\n vec4 norm = normalize( pos - pos2 );\n  return pos + norm * thickness * pos.w * ratio;\n}\nvoid main() {\n  #include <uv_vertex>\n  #include <beginnormal_vertex>\n #include <morphnormal_vertex>\n #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n  #include <begin_vertex>\n #include <morphtarget_vertex>\n #include <skinning_vertex>\n  #include <displacementmap_vertex>\n #include <project_vertex>\n vec3 outlineNormal = - objectNormal;\n  gl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );\n #include <logdepthbuf_vertex>\n #include <clipping_planes_vertex>\n #include <fog_vertex>\n}",fragmentShader:"#include <common>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nuniform vec3 outlineColor;\nuniform float outlineAlpha;\nvoid main() {\n #include <clipping_planes_fragment>\n #include <logdepthbuf_fragment>\n gl_FragColor = vec4( outlineColor, outlineAlpha );\n  #include <tonemapping_fragment>\n #include <encodings_fragment>\n #include <fog_fragment>\n #include <premultiplied_alpha_fragment>\n}",side:a})}function q(b){let a=l[b.uuid];return void 0===a&&(a={material:p(),used:!0,keepAlive:k,count:0},l[b.uuid]=a),a.used=!0,a.material}function r(a){let b=q(a);return m[b.uuid]=a,x(b,a),b}function s(a){let b=a.geometry,c=!1;return void 0!==a.geometry&&(c=!b.isBufferGeometry|| void 0!==b.attributes.normal),!0===a.isMesh&& void 0!==a.material&& !0===c}function t(a){if(!1!==s(a)){if(Array.isArray(a.material))for(let b=0,c=a.material.length;b<c;b++)a.material[b]=r(a.material[b]);else a.material=r(a.material);n[a.uuid]=a.onBeforeRender,a.onBeforeRender=v}}function u(a){if(!1!==s(a)){if(Array.isArray(a.material))for(let b=0,c=a.material.length;b<c;b++)a.material[b]=m[a.material[b].uuid];else a.material=m[a.material.uuid];a.onBeforeRender=n[a.uuid]}}function v(c,d,e,f,a){let b=m[a.uuid];void 0!==b&&w(a,b)}function w(a,c){let b=c.userData.outlineParameters;a.uniforms.outlineAlpha.value=c.opacity,void 0!==b&&(void 0!==b.thickness&&(a.uniforms.outlineThickness.value=b.thickness),void 0!==b.color&&a.uniforms.outlineColor.value.fromArray(b.color),void 0!==b.alpha&&(a.uniforms.outlineAlpha.value=b.alpha)),c.displacementMap&&(a.uniforms.displacementMap.value=c.displacementMap,a.uniforms.displacementScale.value=c.displacementScale,a.uniforms.displacementBias.value=c.displacementBias)}function x(b,a){if("invisible"===b.name)return;let c=a.userData.outlineParameters;b.fog=a.fog,b.toneMapped=a.toneMapped,b.premultipliedAlpha=a.premultipliedAlpha,b.displacementMap=a.displacementMap,void 0!==c?(!1===a.visible?b.visible=!1:b.visible=void 0===c.visible||c.visible,b.transparent=void 0!==c.alpha&&c.alpha<1||a.transparent,void 0!==c.keepAlive&&(l[a.uuid].keepAlive=c.keepAlive)):(b.transparent=a.transparent,b.visible=a.visible),(!0===a.wireframe|| !1===a.depthTest)&&(b.visible=!1),a.clippingPlanes&&(b.clipping=!0,b.clippingPlanes=a.clippingPlanes,b.clipIntersection=a.clipIntersection,b.clipShadows=a.clipShadows),b.version=a.version}function y(){let a;a=Object.keys(m);for(let c=0,f=a.length;c<f;c++)m[a[c]]=void 0;a=Object.keys(n);for(let d=0,g=a.length;d<g;d++)n[a[d]]=void 0;a=Object.keys(l);for(let e=0,h=a.length;e<h;e++){let b=a[e];!1===l[b].used?(l[b].count++,!1===l[b].keepAlive&&l[b].count>60&&delete l[b]):(l[b].used=!1,l[b].count=0)}}this.render=function(a,b){let c,d=!1;if(void 0!==arguments[2]&&(console.warn("THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),c=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead."),d=arguments[3]),void 0!==c&&g.setRenderTarget(c),d&&g.clear(),!1===this.enabled){g.render(a,b);return}let e=g.autoClear;g.autoClear=this.autoClear,g.render(a,b),g.autoClear=e,this.renderOutline(a,b)},this.renderOutline=function(a,b){let c=g.autoClear,d=a.autoUpdate,e=a.background,f=g.shadowMap.enabled;a.autoUpdate=!1,a.background=null,g.autoClear=!1,g.shadowMap.enabled=!1,a.traverse(t),g.render(a,b),a.traverse(u),y(),a.autoUpdate=d,a.background=e,g.autoClear=c,g.shadowMap.enabled=f},this.autoClear=g.autoClear,this.domElement=g.domElement,this.shadowMap=g.shadowMap,this.clear=function(a,b,c){g.clear(a,b,c)},this.getPixelRatio=function(){return g.getPixelRatio()},this.setPixelRatio=function(a){g.setPixelRatio(a)},this.getSize=function(a){return g.getSize(a)},this.setSize=function(a,b,c){g.setSize(a,b,c)},this.setViewport=function(a,b,c,d){g.setViewport(a,b,c,d)},this.setScissor=function(a,b,c,d){g.setScissor(a,b,c,d)},this.setScissorTest=function(a){g.setScissorTest(a)},this.setRenderTarget=function(a){g.setRenderTarget(a)}}}export{OutlineEffect}
