import{BufferAttribute as b,BufferGeometry as c,FileLoader as d,Loader as a}from"three";let _taskCache=new WeakMap;class DRACOLoader extends a{constructor(a){super(a),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(a){return this.decoderPath=a,this}setDecoderConfig(a){return this.decoderConfig=a,this}setWorkerLimit(a){return this.workerLimit=a,this}load(b,f,c,e){let a=new d(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(b,a=>{let b={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(a,b).then(f).catch(e)},c,e)}decodeDracoFile(b,c,a,d){let e={attributeIDs:a||this.defaultAttributeIDs,attributeTypes:d||this.defaultAttributeTypes,useUniqueIDs:!!a};this.decodeGeometry(b,e).then(c)}decodeGeometry(a,b){for(let d in b.attributeTypes){let e=b.attributeTypes[d];void 0!==e.BYTES_PER_ELEMENT&&(b.attributeTypes[d]=e.name)}let f=JSON.stringify(b);if(_taskCache.has(a)){let g=_taskCache.get(a);if(g.key===f)return g.promise;if(0===a.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let j,h=this.workerNextTaskID++,i=a.byteLength,c=this._getWorker(h,i).then(c=>(j=c,new Promise((c,d)=>{j._callbacks[h]={resolve:c,reject:d},j.postMessage({type:"decode",id:h,taskConfig:b,buffer:a},[a])}))).then(a=>this._createGeometry(a.geometry));return c.catch(()=>!0).then(()=>{j&&h&&this._releaseTask(j,h)}),_taskCache.set(a,{key:f,promise:c}),c}_createGeometry(a){let d=new c;a.index&&d.setIndex(new b(a.index.array,1));for(let e=0;e<a.attributes.length;e++){let f=a.attributes[e],g=f.name,h=f.array,i=f.itemSize;d.setAttribute(g,new b(h,i))}return d}_loadLibrary(c,b){let a=new d(this.manager);return a.setPath(this.decoderPath),a.setResponseType(b),a.setWithCredentials(this.withCredentials),new Promise((b,d)=>{a.load(c,b,void 0,d)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;let b="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,a=[];return b?a.push(this._loadLibrary("draco_decoder.js","text")):(a.push(this._loadLibrary("draco_wasm_wrapper.js","text")),a.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(a).then(c=>{let d=c[0];b||(this.decoderConfig.wasmBinary=c[1]);let a=DRACOWorker.toString(),e=["/* draco decoder */",d,"","/* worker */",a.substring(a.indexOf("{")+1,a.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([e]))}),this.decoderPending}_getWorker(a,b){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){let c=new Worker(this.workerSourceURL);c._callbacks={},c._taskCosts={},c._taskLoad=0,c.postMessage({type:"init",decoderConfig:this.decoderConfig}),c.onmessage=function(b){let a=b.data;switch(a.type){case"decode":c._callbacks[a.id].resolve(a);break;case"error":c._callbacks[a.id].reject(a);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+a.type+'"')}},this.workerPool.push(c)}else this.workerPool.sort(function(a,b){return a._taskLoad>b._taskLoad?-1:1});let d=this.workerPool[this.workerPool.length-1];return d._taskCosts[a]=b,d._taskLoad+=b,d})}_releaseTask(a,b){a._taskLoad-=a._taskCosts[b],delete a._callbacks[b],delete a._taskCosts[b]}debug(){console.log("Task load: ",this.workerPool.map(a=>a._taskLoad))}dispose(){for(let a=0;a<this.workerPool.length;++a)this.workerPool[a].terminate();return this.workerPool.length=0,this}}function DRACOWorker(){let a,b;function c(a,j,e,k,b,f){let g=f.num_components(),l=e.num_points(),h=l*g,i=h*b.BYTES_PER_ELEMENT,m=d(a,b),c=a._malloc(i);j.GetAttributeDataArrayForAllPoints(e,f,m,i,c);let n=new b(a.HEAPF32.buffer,c,h).slice();return a._free(c),{name:k,array:n,itemSize:g}}function d(a,b){switch(b){case Float32Array:return a.DT_FLOAT32;case Int8Array:return a.DT_INT8;case Int16Array:return a.DT_INT16;case Int32Array:return a.DT_INT32;case Uint8Array:return a.DT_UINT8;case Uint16Array:return a.DT_UINT16;case Uint32Array:return a.DT_UINT32}}onmessage=function(e){let d=e.data;switch(d.type){case"init":a=d.decoderConfig,b=new Promise(function(b){a.onModuleLoaded=function(a){b({draco:a})},DracoDecoderModule(a)});break;case"decode":let f=d.buffer,g=d.taskConfig;b.then(k=>{let a=k.draco,h=new a.Decoder,e=new a.DecoderBuffer;e.Init(new Int8Array(f),f.byteLength);try{let b=function(b,d,h,i){let j=i.attributeIDs,n=i.attributeTypes,a,e,k=d.GetEncodedGeometryType(h);if(k===b.TRIANGULAR_MESH)a=new b.Mesh,e=d.DecodeBufferToMesh(h,a);else if(k===b.POINT_CLOUD)a=new b.PointCloud,e=d.DecodeBufferToPointCloud(h,a);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!e.ok()||0===a.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+e.error_msg());let l={index:null,attributes:[]};for(let f in j){let o=self[n[f]],m,g;if(i.useUniqueIDs)g=j[f],m=d.GetAttributeByUniqueId(a,g);else{if(-1===(g=d.GetAttributeId(a,b[j[f]])))continue;m=d.GetAttribute(a,g)}l.attributes.push(c(b,d,a,f,o,m))}return k===b.TRIANGULAR_MESH&&(l.index=function i(a,f,c){let g=c.num_faces(),d=3*g,e=4*d,b=a._malloc(e);f.GetTrianglesUInt32Array(c,e,b);let h=new Uint32Array(a.HEAPF32.buffer,b,d).slice();return a._free(b),{array:h,itemSize:1}}(b,d,a)),b.destroy(a),l}(a,h,e,g),i=b.attributes.map(a=>a.array.buffer);b.index&&i.push(b.index.array.buffer),self.postMessage({type:"decode",id:d.id,geometry:b},i)}catch(j){console.error(j),self.postMessage({type:"error",id:d.id,error:j.message})}finally{a.destroy(e),a.destroy(h)}})}}}export{DRACOLoader}
